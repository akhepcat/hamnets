#!/usr/bin/perl
# (c) 2023 Leif Sawyer
# License: GPL 3.0 (see https://github.com/akhepcat/)
# Permanent home:  https://github.com/akhepcat/hamnets
# Direct download: https://raw.githubusercontent.com/akhepcat/hamnets/main/hamnets
# 
use POSIX qw(strftime);
use Getopt::Long;
use Env qw(HOME);

my $PROG=$0;
my $VERSION="2.2";

my %nets;
my %rigs;
my $verbose, $help, $usage, $arg, $color, $myrig, $mydev;
my $RIGCTL;

my $config=$HOME . "/.config/hamnets.cfg";

########################################################

sub fallback {
	##  The rigs we can use => hamlib rig number, device to use, optional args for rigctl
	%{$rigs{"FTdx10"}} = ( "model" => 1042, "dev" => "/dev/ftdx10" );

	##  The 'Nets we can access
	%{$nets{"akerc"}} = ( "rig" => "FTdx10",	# Req: The name of the rig that can use this 'Net
		 "freq" => 14292000,		# Req: The Frequency of the 'Net
		 "mode" => "USB",		# Req: Which modulation mode to use
		   "pbf" => 0,			# Opt: the passband filter width for the mode, 0 uses mode default
		   "nb" => 0,	 		# Opt: Noise Blanker depth (0=off, range dependent on rig)
		   "nr" => 0.1,			# Opt: (Digital) Noise Reduction depth (0=off, range dependent on rig)
		 "rfil" => 2,			# Opt: Roofing filter width to use (values rig dependent)
	       "preamp" => 10,			# Opt: What preamp level to use (values rig dependent)
	       "starts" => "08:30",		# Req: 24h clock, aka military time
	       "duration" => "30",		# Opt: duration in minutes, default is 60m
	       "days" => "MTWRF",		# Req: s'U'nday, M, T, W, thu'R'sday, F, S
	 "desc" => "Alaska Pacific Emergency Preparedness Net",  # Req: The description of the 'Net
		 );
}

##########################################################################
## Color definitions, from https://raw.githubusercontent.com/fidian/ansi/master/images/color-codes.png

my $red=160;	#d70000		# pepsi red
my $yellow=226;	#ffff00		# yellow
my $brgreen=82;	#5fff00 	# bright green
my $green=34;	#00af00		# islam green
my $orange=136;	#af8700		# dark goldenrod
my $brown=99;	#875f5f		# pastel brown
my $grey=248;	#a8a8a8		# dark grey

##########################################################################
sub perror {
	my @args =shift;
	
	if ($color) {
		print "\e[1m\e[38;5;${red}m", @args, "\e[0m";
	} else {
		print @args;
	}
}

sub pwarn {
	my @args =shift;
	
	if ($color) {
		print "\e[1m\e[38;5;${yellow}m", @args, "\e[0m";
	} else {
		print @args;
	}
}

sub cprint {
	my ($c, $text) = @_;
	
	if ($color) {
		pcolor($c); print $text; pcolor(-1);
	} else {
		print $text;
	}
}

sub pcolor {
	my $c = shift;
	if ($c >=0) {
		print "\e[38;5;${c}m";
	} else {
		print "\e[0m";
	}
}

sub set_net {
	my $n=shift;
	my $cmdlist;
	
	# Set the initial frequency; some radios want this first... 
	$cmdlist.=qq|F $nets{$n}{"freq"}\n|;

	# Set the Mode and bandwidth next....
	$cmdlist.=qq|M $nets{$n}{"mode"} $nets{$n}{"pbf"}\n|;

	# Re-set the frequency after mode, so we don't run into offsetting
	$cmdlist.=qq|F $nets{$n}{"freq"}\n|;

	# next set repeater offset frequencies, if applicable
	if ($nets{$n}{"mode"} eq "FM" || $nets{$n}{"mode"} eq "WFM") {
		my $sf=0; my $sp=0; my $rshift="simplex";

		if (defined($nets{$n}{"shift"})) {
			$rshift = $nets{$n}{"shift"};

			if ($rshift eq "simplex") {
				$sf=0; $sp="0";
			} elsif ( m/\+/,$rshift ) {
				$sf = s/\+//,$rshift;
				$sp = "+";
			} elsif ( m/-/,$rshift ) {
				$sf = s/-//,$rshift;
				$sp = "-";
			} else {
				$sf=0; $sp="0";	# dunno what they wanted, but it wasn't clear
			}
		}

		if ( $sp ne "0" && $sf == 0 ) {
			# Automatic repeater offsets as follows
			if ($nets{$n}{"freq"} >= 29500000 && $nets{$n}{"freq"} <= 29700000 ) {
				$sf = 100000;  $sp = "-";
			} elsif ($nets{$n}{"freq"} >= 51620000 && $nets{$n}{"freq"} <= 539800000 ) {
				$sf = 500000;  $sp = "-";
			} elsif ($nets{$n}{"freq"} >= 145200000 && $nets{$n}{"freq"} <= 146970000 ) {
				$sf = 600000;  $sp = "-";
			} elsif ($nets{$n}{"freq"} >= 147000000 && $nets{$n}{"freq"} <= 147390000 ) {
				$sf = 600000;  $sp = "+";
			} elsif ($nets{$n}{"freq"} >= 223850000 && $nets{$n}{"freq"} <= 224980000 ) {
				$sf = 1600000;  $sp = "-";
			} elsif ($nets{$n}{"freq"} >= 440000000 && $nets{$n}{"freq"} <= 445000000 ) {
				$sf = 5000000;  $sp = "+";
			} elsif ($nets{$n}{"freq"} >= 447000000 && $nets{$n}{"freq"} <= 450000000 ) {
				$sf = 5000000;  $sp = "-";
			} elsif ($nets{$n}{"freq"} >= 1282000000 && $nets{$n}{"freq"} <= 12940000000 ) {
				$sf = 12000000;  $sp = "-";
			} else {
				$sf = 0; $sp = "0";
			}
		}
		
		$cmdlist.=qq|O $sf\n|;
		$cmdlist.=qq|R $sp\n|;
	}

	# Next we set the CTCSS tone
	if (defined($nets{$n}{"tone"})) {
		my $hz = $nets{$n}{"tone"} * 10;
		$cmdlist.=qq|C $hz\n|;
	}
	

	if (defined($nets{$n}{"rfil"})) {
		# Set the bandpass filter to 3khz
		$cmdlist.=qq|L ROOFINGFILTER $nets{$n}{"rfil"}\n|;
		# Set the preamp to "amp1"
		$cmdlist.=qq|L PREAMP $nets{$n}{"preamp"}\n|;
	}
	
	if (defined($nets{$n}{"nb"})) {
		# Check for noise blanking
		if ($nets{$n}{"nb"} > 0) {
			# Set the noise blanker level NB(1..10/1)
			$cmdlist.=qq|L NB $nets{$n}{"nb"}\n|;
		} else {
			# Disable the noise blanker
			$cmdlist.=qq|L NB 0\n|;
		}
	}

	if (defined($nets{$n}{"nr"})) {
		# Check for noise reduction
		if ($nets{$n}{"nr"} > 0) {
			# Set the DNR to level 1  ( NR(0..1/ 0, .1, .15, .2 ...)
			$cmdlist.=qq|L NB $nets{$n}{"nr"}\n|;
			$cmdlist.=qq|U NR 1\n|;
		} else {
			# Disable the digital noise reducer
			$cmdlist.=qq|U NR 0\n|;
		}
	}

	# Lastly, figure out which rig to send it to, and push the configs!
	my $r, $d, $m;

	if ( defined($myrig) && defined($rigs{$myrig}) ) {
		$r=$myrig;
		$m=$rigs{$myrig}{'model'};
		pwarn "Attempting to force Net to use $myrig, not all features may be supported\n";
	} else {
		$r=$nets{$n}{"rig"};
		$m=$rigs{$r}{'model'};
	}

	if (defined($mydev) && ( -e $mydev && -R _ ) ) {
		$d=$mydev;
	} else {
		$d=$rigs{$r}{"dev"};
	}

	if ( ! $RIGCTL ) {
		$RIGCTL="rigctl";
	}
	system( qq^bash -c "echo '$cmdlist' | $RIGCTL -r $d -m $m $rigs{$r}{"opts"} - \n" ^ );
}

sub pweek {
    $_ = shift;
    my $s;

    if (m/U/) { $s = "U"; } else {$s = ".";}
    if (m/M/) { $s .= "M"; } else {$s .= ".";}
    if (m/T/) { $s .= "T"; } else {$s .= ".";}
    if (m/W/) { $s .= "W"; } else {$s .= ".";}
    if (m/R/) { $s .= "R"; } else {$s .= ".";}
    if (m/F/) { $s .= "F"; } else {$s .= ".";}
    if (m/S/) { $s .= "S"; } else {$s .= ".";}

    return $s;
}

sub dsum {
    my $n = shift;
    my $s=0; my $r=0;
    my $t = $nets{$n}{"starts"};

    $_ = $nets{$n}{"days"};

    if (m/U/) { $s += 7**7; }
    if (m/M/) { $s += 7**6; }
    if (m/T/) { $s += 7**5; }
    if (m/W/) { $s += 7**4; }
    if (m/R/) { $s += 7**3; }
    if (m/F/) { $s += 7**2; }
    if (m/S/) { $s += 7**1; }

    $r = ($s * 10000) + (1440 - timetomins($t));
    return ($r);
}


sub istoday {
	$_ = shift;
	my $dow = (localtime)[6];
	my $ret = 0;
	
	if ( $dow == 0 && m/U/ ) { $ret = 1; }
	if ( $dow == 1 && m/M/ ) { $ret = 1; }
	if ( $dow == 2 && m/T/ ) { $ret = 1; }
	if ( $dow == 3 && m/W/ ) { $ret = 1; }
	if ( $dow == 4 && m/R/ ) { $ret = 1; }
	if ( $dow == 5 && m/F/ ) { $ret = 1; }
	if ( $dow == 6 && m/S/ ) { $ret = 1; }

	return $ret;
}

sub usage {
	perror "usage: ${PROG} -[vchrdR] --[rig|dev] [net]\n";
	print "       ver: $VERSION\n";
	pwarn "\t -v  verbosely show all nets, instead of just for today\n";
	pwarn "\t -c  enable Color\n";
	pwarn "\t -R  list configured rigs\n";
	pwarn "\t -r|--rig  force a specific rig for Net\n";
	pwarn "\t -d|--dev  force a specific device for rig\n";
	pwarn "\t -h  this help\n";
}

sub timetomins {
	$_ = shift;
	my ($h,$m) = split(/:/);
	my $t = 0;
	
	$t = ($h * 60 ) + $m;

	return($t);
}
	
sub soon {
	my $s = timetomins(int($_[0]));
	my $dur = int($_[1])>60?int($_[1]):60;
	my $t = timetomins( (localtime())[2] . ":" . (localtime())[1] );
	my $d = $s - $t;	# delta between start and now
	
	if ($s > $t) {
		# upcoming events
		if ( $d <= 15 ) {
			return 1;
		} elsif ($d <= 90 ) {
			return 2;
		} else {
			return 3;
		}
	} else {
		if ( (($dur != 0) && ($d > -($dur))) ) {
			return 4;
		}
	}
	return 0;
}

sub listrigs {
	printf("%10.10s | %10.10s | %s\n", "Rig", "Device", "rigctl mode");

	foreach my $rig (sort keys %rigs) {
		printf("%10.10s | %10.10s | %5i\n", $rig, $rigs{$rig}{'dev'}, $rigs{$rig}{'model'});
	}
}

sub displaynets {
	if ($verbose) {
		cprint(51, "  net can be:\n");
	} else {
	        cprint(51, "  net for today can be:\n");
	}
	if ($color) {
		cprint($grey,  "     * time passed\n");
		cprint($brgreen,  "     * Currently in progress\n");
		cprint($green,  "     * starting within 15m\n");
		cprint($orange, "     * starting within 90m\n");
		cprint($brown,  "     * starting much later\n");
	}

	foreach my $rig (sort keys %rigs) {
		if ( -e $rigs{$rig}{"dev"} && -R _ ) {
			printf("\n\t%s:\n", $rig );
			foreach my $net (sort { ( dsum($b) <=> dsum($a) ) } keys %nets) {
				if ( $color && istoday($nets{$net}{"days"}) ) {
					my $s;
					if (defined($nets{$net}{"duration"})) {
						$s = soon($nets{$net}{"starts"}, $nets{$net}{"duration"});
					} else {
						$s = soon($nets{$net}{"starts"});
					}
					if ( $s eq 1) {
						pcolor($green);
					} elsif ( $s eq 2) {
                                                pcolor($orange);
					} elsif ( $s eq 3) {
                                                pcolor($brown);
					} elsif ( $s eq 4) {
                                                pcolor($brgreen);
					} else {
						pcolor($grey);
					}
				}

				printf("\t%10s (%8.04f MHz %3.3s) - %5.5s (%s) - %s\n", 
					$net, 
					$nets{$net}{"freq"} / 1000000,
					$nets{$net}{"mode"}, 
					$nets{$net}{"starts"}, 
					pweek($nets{$net}{"days"}), 
					$nets{$net}{"desc"} ) 
					if ( $nets{$net}{"rig"} eq $rig && ($verbose || istoday($nets{$net}{"days"}))) ;

				if ($color) {
					pcolor(-1);
				}
			}
		}
	}
	printf("\n");
}


############################################################


#Get the options from the command line.
GetOptions(
  "v!"  => \$verbose,
  "h!"  => \$help,
  "c!"  => \$color,
  "r|rig=s" => \$myrig,
  "R!" => \$rlist,
  "d|dev=s" => \$mydev,
);

$arg = $ARGV[0];

$PROG =~ s|^.*/||g;
$_ = $PROG;
if ( (m/c$/) || (m/color$/)) {
	$color=1;
}

if ( $help ) {
	usage;
	exit 1;
}

if ( -r "$config" ) {
#	pwarn "Reading user configuration from $config\n";
	unless ($return = do "$config") {
		if ($@) { warn "couldn't parse $config: $@"; exit 1; }
		if (!defined($return)) { warn "couldn't evaluate $config: $!"; exit 1;}
	}
	eval `cat $config`;
} else {
	pwarn "Can't read from $config!\n";
}

if ( ! $RIGCTL ) {
	$RIGCTL="rigctl";
}

if ( $rlist ) {
	listrigs;
	exit 0;
}

if ( !(%rigs) || !(%nets) ) {
	fallback;
}

if ( ! $arg ) {
	displaynets;
	exit 0;
}

if (defined($nets{$arg})) {
	pwarn "Selected $arg\n";
	set_net($arg);
} else {
	perror "ERROR: no such net\n";
}

printf("\n");
